<section class="gh-content gh-canvas is-body">
  <p><strong>시리즈 완결</strong> — 이론에서 구현까지, <code>Gumbel AlphaZero</code>의 혁신적 아이디어들이 어떻게 적은 시뮬레이션에서도 정책 개선을 보장하는지, 그리고 실제 프로덕션 환경에서 어떻게 활용할 수 있는지 종합적으로 정리합니다.</p>

  <hr>

  <figure class="kg-card kg-image-card">
   <%= post_detail_image_tag("cpu_scheduler_01.webp") %>
  </figure>

  <h2>1. ⚙ CPU 스케줄링 개요</h2>

  <h3>1.1. CPU 스케줄링의 기본 개념</h3>
  <ul>
    <li>
      CPU 스케줄링은 여러 프로세스가 CPU를 효율적으로 사용할 수 있도록 CPU 사용 권한을 할당하는 운영체제의 핵심 기능입니다.
    </li>
    <li>
      CPU burst와 I/O request의 빈도와 지속 시간을 고려하여 적절히 조율하는 것이 중요합니다.
    </li>
    <li>
      CPU burst duration은 일반적으로 밀리초 단위이며, CPU bound 작업과 I/O bound 작업이 존재합니다.
    </li>
    <li>
      CPU 스케줄러는 단기 스케줄러(short-term scheduler)라고도 불립니다.
    </li>
  </ul>
  <figure class="kg-card kg-image-card kg-card-hascaption">
    <%= post_detail_image_tag("cpu_scheduler_02.webp") %>
    <figcaption>
      <span style="white-space: pre-wrap;">CPU 스케줄링의 기본 개념</span>
    </figcaption>
  </figure>

  <h3>1.2. 스케줄링의 역할과 작동 시점</h3>
  <p>CPU 스케줄러는 다음과 같은 상황에서 동작합니다:</p>
  <ul>
    <li>
      CPU 스케줄링은 프로세스가 입장(admitted)하거나 종료(exit)할 때
    </li>
    <li>
      인터럽트 발생 시
    </li>
    <li>
      프로세스가 입출력(I/O) 대기 상태로 전환될 때
    </li>
  </ul>
  <p>스케줄링은 선점형(preemptive)과 비선점형(non-preemptive)으로 나뉘며, 인터럽트나 커널 모드에서 선점이 고려됩니다.</p>
  <figure class="kg-card kg-image-card kg-card-hascaption">
    <%= post_detail_image_tag("cpu_scheduler_03.webp") %>
    <figcaption>
      <span style="white-space: pre-wrap;">프로세스 상태 변화에 따른 스케줄링 흐름도</span>
    </figcaption>
  </figure>
  <p>이 중 1번과 4번 전환 시 선점형 스케줄링이 발생합니다.</p>

  <h3>1.3. 디스패처와 컨텍스트 스위칭</h3>
  <ul>
    <li>
      <strong>디스패처(dispatcher)</strong>: <em>Ready 리스트에서 실행할 프로세스를 선택하여 CPU에 할당하는 역할을 합니다.</em> 
    </li>
    <li>
      <strong>컨텍스트 스위칭(context switching)</strong>: <em>현재 실행 중인 프로세스의 상태를 저장하고, 새 프로세스의 상태를 복원하는 과정으로, 사용자 모드 전환과 프로그램 재시작 위치 점프를 포함합니다. 하지만 컨텍스트 스위칭은 시스템 오버헤드를 발생시킵니다.</em>
    </li>
  </ul>
  <figure class="kg-card kg-image-card kg-card-hascaption">
    <%= post_detail_image_tag("cpu_scheduler_04.webp") %>
    <figcaption>
      <span style="white-space: pre-wrap;">디스패처는 Ready 리스트에서 실행할 프로세스를 선택하여 CPU에 할당하는 역할을 합니다.</span>
    </figcaption>
  </figure>

  <h2>2. ⚙ 주요 스케줄링 알고리즘</h2>

  <h3>2.1. FCFS (First-Come, First-Served)</h3>
  <ul>
    <li>
      가장 간단한 비선점형 스케줄링 알고리즘으로, 먼저 도착한 프로세스가 먼저 CPU를 할당받습니다.
    </li>
    <li>
      단점으로는 긴 작업이 앞에 있으면 뒤에 있는 짧은 작업들이 대기하는 <strong>‘호위 효과(Convoy Effect)’</strong>가 발생합니다.
    </li>
    <li>
      이를 해결하기 위해 뒤에 소개할 <strong>SJF</strong>나 <strong>Round Robin</strong> 알고리즘이 사용됩니다.
    </li>
  </ul>
  <figure class="kg-card kg-image-card kg-card-hascaption">
    <%= post_detail_image_tag("cpu_scheduler_05.webp") %>
    <figcaption>
      <span style="white-space: pre-wrap;">FCFS는 가장 먼저 도착한 프로세스가 먼저 CPU를 할당받는 비선점형 스케줄링 알고리즘입니다.</span>
    </figcaption>
  </figure>

  <h3>2.2. SJF (Shortest Job First)</h3>
  <ul>
    <li>
      실행 시간이 가장 짧은 작업을 우선 실행하는 알고리즘입니다.
    </li>
    <li>
      이론적으로 평균 대기 시간을 최소화하지만, 긴 작업이 계속 대기하는 기아 현상(Starvation)이 발생할 수 있습니다.
    </li>
    <li>
      실행 시간 예측이 어려운 문제는 과거 실행 시간을 기반으로 한 예측 알고리즘으로 해결합니다.
    </li>
  </ul>
  <figure class="kg-card kg-image-card kg-card-hascaption">
    <%= post_detail_image_tag("cpu_scheduler_06.webp") %>
    <figcaption>
      <span style="white-space: pre-wrap;">SJF는 실행 시간이 가장 짧은 작업을 우선 실행하는 알고리즘입니다.</span>
    </figcaption>
  </figure>

  <h3>2.3. Round Robin</h3>
  <ul>
    <li>
      각 프로세스에 동일한 시간 할당량(Time Quantum)을 주고 순환하며 실행하는 선점형 스케줄링입니다.
    </li>
    <li>
      컨텍스트 스위칭 오버헤드가 발생할 수 있으나, 다단계 큐 같은 차등적 시간 할당량 적용으로 문제를 완화할 수 있습니다.
    </li>
    <li>
      짧은 시간 할당량은 응답성을 높이지만 오버헤드를 증가시키고, 긴 시간 할당량은 FCFS와 유사한 동작을 합니다.
    </li>
  </ul>
  <figure class="kg-card kg-image-card kg-card-hascaption">
    <%= post_detail_image_tag("cpu_scheduler_07.webp") %>
    <figcaption>
      <span style="white-space: pre-wrap;">각 프로세스에 동일한 시간 할당량(Time Quantum)을 주고 순환하며 실행하는 선점형 스케줄링입니다.</span>
    </figcaption>
  </figure>

  <h2>3. ⚙ 고급 스케줄링 기법</h2>

  <h3>3.1. 다단계 큐 (Multilevel Queue)</h3>
  <ul>
    <li>
      프로세스 유형별로 여러 개의 큐를 구성하고, 각 큐마다 다른 스케줄링 알고리즘과 우선순위를 적용합니다.
    </li>
    <li>
      예를 들어, 시스템 프로세스는 높은 우선순위의 큐에서 Round Robin으로, 배치 프로세스는 낮은 우선순위의 큐에서 FCFS로 스케줄링할 수 있습니다.
    </li>
    <li>
      각 큐는 시분할(Time Slice) 방식으로 CPU 시간을 분배받아 사용합니다.
    </li>
    <li>
      다단계 큐는 사용자와 시스템 요구에 맞춰 유연한 스케줄링 정책을 구현할 수 있습니다.
    </li>
  </ul>
  <figure class="kg-card kg-image-card kg-card-hascaption">
    <%= post_detail_image_tag("cpu_scheduler_08.webp") %>
    <figcaption>
      <span style="white-space: pre-wrap;">다단계 큐는 사용자와 시스템 요구에 맞춰 유연한 스케줄링 정책을 구현할 수 있습니다.</span>
    </figcaption>
  </figure>

  <h2>4. 🏁 마치며</h2>
  <p>CPU 스케줄러는 운영체제의 핵심 구성 요소로, 다양한 스케줄링 알고리즘과 기법을 통해 시스템 자원을 효율적으로 관리합니다. 기본적인 <strong>FCFS</strong>, <strong>SJF</strong>, <strong>Round Robin</strong> 알고리즘부터 <strong>다단계 큐</strong>와 같은 고급 기법까지, 각각의 장단점과 적용 상황을 이해하는 것이 중요합니다. 이를 통해 시스템 성능 향상과 공정한 자원 분배를 달성할 수 있습니다.</p>
</section>
